// vite-plugin-use-main.ts
import type { Plugin, ResolvedConfig, Rollup } from 'vite';
import { parse as babelParse } from '@babel/parser';
import _traverse, { NodePath } from '@babel/traverse';
import * as BabelTypes from '@babel/types';
import MagicString from 'magic-string';
import path from 'node:path';
import fs from 'fs-extra';
import { normalizePath } from 'vite';
import { transformSync } from '@babel/core';

// Fix for ESM/CJS interop
const traverse = (_traverse as any).default || _traverse;

// --- Interfaces ---
interface ParamInfo {
    name: string;
    typeString: string;
}

interface UseMainFunctionManifestEntry {
    id: string;
    name: string;
    params: ParamInfo[];
    paramsString: string;
    returnTypeString: string;
    body: string;
    filePath: string;
}

type UseMainManifest = Record<string, UseMainFunctionManifestEntry>;

// --- Constants ---
const PLUGIN_NAME = 'vite-plugin-use-main';
const TEMP_DIR_NAME = '.vite-plugin-use-main';
const MANIFEST_FILE = 'use-main-manifest.json';
const GENERATED_PRELOAD_BRIDGE = '_generated_preload_bridge.js';
const GENERATED_MAIN_HANDLERS = '_generated_main_handlers.js';
const GENERATED_TYPES_FILE = 'rpcTree.gen.ts';
// const IPC_CHANNEL = 'ipc-use-main';

// --- Plugin State ---
let collectedFunctions = new Map<string, UseMainFunctionManifestEntry>();
let mainHandlersGenerated = false;
let preloadBridgeGenerated = false;
let tempDirPath = '';
let manifestPath = '';

// --- Helper Functions ---

function stripTypeAnnotations(code: string): string {
    // Wrap the code in an async generator function to support all cases
    const wrappedCode = `async function* __dummy__() {\n${code}\n}`;
    
    const result = transformSync(wrappedCode, {
        filename: 'temp.ts',
        plugins: [
            ['@babel/plugin-transform-typescript', { 
                isTSX: false,
                allowNamespaces: true,
            }]
        ],
        retainLines: false,
        configFile: false,
        babelrc: false,
    });

    if (!result?.code) return code;

    // Extract the function body, removing the wrapper
    const match = result.code.match(/async function\* __dummy__\(\) {\s*([\s\S]*?)\s*}$/);
    return match ? match[1].trim() : code;
}

export function generateId(root: string, filePath: string, functionName: string | null): string {
    const absoluteFilePath = path.isAbsolute(filePath) ? filePath : path.resolve(root, filePath);
    const relativePath = normalizePath(path.relative(root, absoluteFilePath));
    return `${relativePath}::${functionName || '_anonymous_'}`;
}

function isUseMainDirective(node: BabelTypes.Node | undefined | null): node is BabelTypes.ExpressionStatement & { expression: BabelTypes.StringLiteral } {
    return !!node && node.type === 'ExpressionStatement' && node.expression.type === 'StringLiteral' && node.expression.value === 'use main';
}

function getNodePosition(node: BabelTypes.Node | undefined | null): { start: number | null; end: number | null } {
    return { start: node?.start ?? null, end: node?.end ?? null };
}

function getTypeAnnotationString(node: BabelTypes.Node | null | undefined, code: string): string {
    if (node?.type === 'TSTypeAnnotation' && node.typeAnnotation) {
        const pos = getNodePosition(node.typeAnnotation);
        if (pos.start !== null && pos.end !== null) {
            return code.substring(pos.start, pos.end);
        }
    }
    return 'any';
}

function extractParamInfo(param: BabelTypes.Node, code: string): ParamInfo {
    let paramName = 'unknown';
    if (BabelTypes.isIdentifier(param)) {
        paramName = param.name;
    } else if (BabelTypes.isAssignmentPattern(param) && BabelTypes.isIdentifier(param.left)) {
        paramName = param.left.name;
    } else if (BabelTypes.isRestElement(param) && BabelTypes.isIdentifier(param.argument)) {
        paramName = `...${param.argument.name}`;
    }
    const typeString = getTypeAnnotationString((param as any).typeAnnotation, code);
    return { name: paramName, typeString };
}

function generatePreloadBridgeCode(functions: UseMainFunctionManifestEntry[]): string {
    return `
// Preload bridge code generated by vite-plugin-use-main
const { contextBridge, ipcRenderer } = require('electron');

// Create the mainApi object
const mainApi = {};

${functions.map(func => `
// Bridge for ${func.name}
mainApi.${func.name} = async (...args) => {
    try {
        console.log('[Preload Bridge] ${func.name} called with args:', args);
        const result = await ipcRenderer.invoke('${func.id}', ...args);
        console.log('[Preload Bridge] Received result:', result);
        return result;
    } catch (error) {
        console.error('[Preload Bridge] Error in ${func.name}:', error);
        throw new Error(error?.message || 'Unknown error');
    }
};`).join('\n')}

// Expose the API to the renderer process
contextBridge.exposeInMainWorld('mainApi', mainApi);
`;
}

function generateMainHandlerCode(functions: UseMainFunctionManifestEntry[]): string {
    return `
// Main process handlers generated by vite-plugin-use-main
const { ipcMain } = require('electron');
const os = require('node:os');

${functions.map(func => `
// Handler for ${func.name}
ipcMain.handle('${func.id}', async (_event, ...args) => {
    try {
        console.log('[Main Handler] ${func.name} received args:', args);
        // Map args to named parameters
        const params = {};
        ${func.params.map((p, i) => `params.${p.name.replace('...', '')} = args[${i}];`).join('\n        ')}
        
        const result = await (function() {
            // Destructure params to make them available in scope
            const { ${func.params.map(p => p.name.replace('...', '')).join(', ')} } = params;
            ${stripTypeAnnotations(func.body)}
        })();
        console.log('[Main Handler] ${func.name} returning result:', result);
        return result;
    } catch (error) {
        console.error('[Main Handler] Error in ${func.name}:', error);
        throw new Error(error?.message || 'Unknown error');
    }
});`).join('\n')}

// Export setup function
exports.setupMainHandlers = () => {
    console.log('[Main Process] Handlers setup complete');
};
`;
}

function generateTypeDefinitions(functions: UseMainFunctionManifestEntry[]): string {
    return `// Generated by ${PLUGIN_NAME} - Do not edit manually!

// This file provides type definitions for the API exposed via contextBridge ('mainApi')
// It is automatically generated based on the "use main" functions found in your codebase.

export interface MainApi {
${functions.map(func => {
    // Construct parameter list
    const paramList = func.params.map(p => `${p.name}: ${p.typeString}`).join(', ');
    
    // Handle return type - ensure it's wrapped in Promise
    let returnType = func.returnTypeString;
    if (returnType === 'void') {
        returnType = 'Promise<void>';
    } else if (returnType !== 'any' && !returnType.startsWith('Promise<')) {
        returnType = `Promise<${returnType}>`;
    } else if (returnType === 'any') {
        returnType = 'Promise<any>';
    }
    
    return `  ${func.name}(${paramList}): ${returnType};`;
}).join('\n')}
}

// Declare it on the window object for convenience
declare global {
  interface Window {
    mainApi: MainApi;
  }
}
`;
}

// --- Plugin Implementation ---
export function useMainPlugin(target: 'renderer' | 'preload' | 'main'): Plugin {
    let config: ResolvedConfig;
    let logger: ResolvedConfig['logger'];

    return {
        name: `${PLUGIN_NAME}-${target}`,
        enforce: 'pre', // Run before other plugins

        configResolved(resolvedConfig: ResolvedConfig) {
            config = resolvedConfig;
            logger = config.logger || { info: console.log, warn: console.warn, error: console.error, clearScreen: (() => {}) };
            tempDirPath = normalizePath(path.resolve(config.root, 'node_modules', TEMP_DIR_NAME));
            manifestPath = normalizePath(path.join(tempDirPath, MANIFEST_FILE));

            if (target === 'renderer') {
                try { 
                    fs.ensureDirSync(tempDirPath);
                    // Also ensure shared directory exists
                    const sharedDir = path.resolve(config.root, 'src', 'shared');
                    fs.ensureDirSync(sharedDir);
                    
                    // Ensure initial type file exists
                    const typesPath = path.join(sharedDir, GENERATED_TYPES_FILE);
                    if (!fs.existsSync(typesPath)) {
                        fs.writeFileSync(typesPath, `// Generated by ${PLUGIN_NAME}\nexport interface MainApi {}\n`);
                    }
                } catch (e: any) { 
                    logger.error(`Failed to ensure directories: ${e.message}`);
                }
                collectedFunctions.clear();
                mainHandlersGenerated = false;
                preloadBridgeGenerated = false;
            }
        },

        // Add configureServer hook for dev mode
        configureServer(server) {
            if (target === 'renderer') {
                // Watch the manifest file for changes
                server.watcher.add(manifestPath);
                
                // Watch handler
                server.watcher.on('change', async (changedPath) => {
                    if (changedPath === manifestPath) {
                        try {
                            const manifest: UseMainManifest = await fs.readJSON(manifestPath);
                            const functions: UseMainFunctionManifestEntry[] = Object.values(manifest);
                            if (functions.length > 0) {
                                const typeDefinitions = generateTypeDefinitions(functions);
                                const typesOutputPath = normalizePath(path.resolve(config.root, 'src', 'shared', GENERATED_TYPES_FILE));
                                await fs.writeFile(typesOutputPath, typeDefinitions);
                                logger?.info(`[${PLUGIN_NAME}] Updated type definitions at ${typesOutputPath}`);
                            }
                        } catch (e: any) {
                            logger?.error(`[${PLUGIN_NAME}] Error updating types: ${e.message}`);
                        }
                    }
                });
            }
        },

        // Add buildStart hook to generate types immediately
        async buildStart() {
            if (target === 'renderer') {
                // Read manifest
                let manifest: UseMainManifest = {};
                try {
                    manifest = await fs.readJSON(manifestPath);
                } catch (e) {
                    logger?.warn(`[${PLUGIN_NAME}] No manifest found at ${manifestPath}`);
                    return;
                }

                const functions = Object.values(manifest);
                if (functions.length > 0) {
                    // Generate type definitions
                    const typeDefinitions = generateTypeDefinitions(functions);

                    // Write to file
                    const typesOutputPath = normalizePath(path.resolve(config.root, 'src', 'shared', GENERATED_TYPES_FILE));
                    try {
                        await fs.ensureDir(path.dirname(typesOutputPath));
                        await fs.writeFile(typesOutputPath, typeDefinitions);
                        logger?.info(`[${PLUGIN_NAME}] Generated type definitions at ${typesOutputPath}`);
                    } catch (e: any) {
                        logger?.error(`[${PLUGIN_NAME}] Failed to write type definitions: ${e.message}`);
                    }
                }
            }
        },

        async transform(code: string, id: string) {
            const VITE_INTERNAL_QUERY = '?';
            const cleanId = id.includes(VITE_INTERNAL_QUERY) ? id.split(VITE_INTERNAL_QUERY)[0] : id;
            const normalizedId = normalizePath(cleanId);
            if (!/\.(t|j)sx?$/.test(normalizedId) || normalizedId.includes('/node_modules/') || normalizedId.startsWith(tempDirPath) || (!code.includes('"use main"') && !code.includes("'use main'"))) { return null; }

            logger?.info(`[${PLUGIN_NAME}:${target}] Processing file: ${normalizedId}`);

            let ast: BabelTypes.File;
            try {
                ast = babelParse(code, { sourceType: 'module', plugins: ['jsx', 'typescript'], sourceFilename: id });
            } catch (e: any) {
                logger?.warn(`[${PLUGIN_NAME}] Failed to parse ${normalizedId}: ${e.message}. Skipping.`, { timestamp: true });
                return null;
            }

            const magicString = new MagicString(code, { filename: id });
            let changed = false;
            const functionsInFile = new Map<string, UseMainFunctionManifestEntry>();

            // --- AST Traversal ---
            traverse(ast, {
                 // Explicitly visit all function-like node types that can have bodies
                 FunctionDeclaration(path) { processFunctionNode(path, code); },
                 FunctionExpression(path) { processFunctionNode(path, code); },
                 ArrowFunctionExpression(path) { processFunctionNode(path, code); },
                 ClassMethod(path) { processFunctionNode(path, code); },
                 ObjectMethod(path) { processFunctionNode(path, code); } // Add ObjectMethod visitor
            });

            // --- Centralized Function Processing Logic ---
            function processFunctionNode(path: NodePath<BabelTypes.Function | BabelTypes.ClassMethod | BabelTypes.ObjectMethod>, originalCode: string) {
                const node = path.node;
                const parent = path.parent;
                const parentPath = path.parentPath;

                // Ensure we have a BlockStatement body
                let bodyNode: BabelTypes.BlockStatement | null = null;
                if (BabelTypes.isBlockStatement(node.body)) { bodyNode = node.body; } else { return; }

                // Ensure "use main" is the first directive/statement
                let directiveNode: BabelTypes.Directive | BabelTypes.Node | null = null;
                 if (bodyNode.directives?.length > 0 && bodyNode.directives[0].value.value === 'use main') { directiveNode = bodyNode.directives[0]; }
                 else if (bodyNode.body?.length > 0 && isUseMainDirective(bodyNode.body[0])) { directiveNode = bodyNode.body[0]; }
                 if (!directiveNode) { return; }

                // --- Infer Name (Handle all relevant types) ---
                let functionName: string | null = null;
                 if (node.type === 'FunctionDeclaration' && node.id) { functionName = node.id.name; }
                 else if (node.type === 'FunctionExpression' && node.id) { functionName = node.id.name; }
                 // Use node.key for methods, check if Identifier BEFORE checking computed
                 else if ((node.type === 'ClassMethod' || node.type === 'ObjectMethod') && BabelTypes.isIdentifier(node.key) && !node.computed) { functionName = node.key.name; }
                 else { // Infer from context
                     if (parent?.type === 'VariableDeclarator' && parent.id.type === 'Identifier') { functionName = parent.id.name; }
                     else if (parentPath?.isObjectProperty() && BabelTypes.isIdentifier(parentPath.node.key) && !parentPath.node.computed) { functionName = parentPath.node.key.name; } // Check ObjectProperty parent
                     else if (parentPath?.isClassProperty() && BabelTypes.isIdentifier(parentPath.node.key) && !parentPath.node.computed) { functionName = parentPath.node.key.name; } // Check ClassProperty parent
                     else if (parent?.type === 'AssignmentExpression' && parent.left.type === 'Identifier') { functionName = parent.left.name; }
                 }

                 // --- Skip Computed Property Names ---
                 // Check if the key itself is computed AFTER trying to get an Identifier name
                 if ( (node.type === 'ClassMethod' || node.type === 'ObjectMethod') && node.computed) {
                      logger?.warn(`[${PLUGIN_NAME}] Skipping method with computed name in ${normalizedId}.`, { timestamp: true });
                      return; // Skip this specific node
                 }
                 // Also check if assigned to a computed property
                 if ( parentPath?.isObjectProperty() && parentPath.node.computed) {
                     logger?.warn(`[${PLUGIN_NAME}] Skipping function assigned to computed object property in ${normalizedId}.`, { timestamp: true });
                     return; // Skip this specific node
                 }
                 if ( parentPath?.isClassProperty() && parentPath.node.computed) {
                    logger?.warn(`[${PLUGIN_NAME}] Skipping function assigned to computed class property in ${normalizedId}.`, { timestamp: true });
                    return; // Skip this specific node
                }


                if (!functionName) { logger?.warn(`[${PLUGIN_NAME}] Found anonymous "use main"... Skipping.`, { timestamp: true }); return; }
                const uniqueId = generateId(config.root, normalizedId, functionName);

                // --- Duplicate Check ---
                if (collectedFunctions.has(uniqueId)) {
                    logger?.warn(`[${PLUGIN_NAME}] Duplicate function ID encountered: ${uniqueId}. Skipping.`, { timestamp: true });
                    return; // Skip duplicate
                }

                // --- Extract Parameters with Types ---
                const paramsInfo: ParamInfo[] = [];
                let paramsString = '';
                if ('params' in node && node.params.length > 0) {
                    const firstParam = node.params[0];
                    const lastParam = node.params[node.params.length - 1];
                    const bodyStartPos = getNodePosition(bodyNode).start;
                    const firstParamPosStart = getNodePosition(firstParam).start;
                    const lastParamPosEnd = getNodePosition(lastParam).end;

                    if (firstParamPosStart !== null && lastParamPosEnd !== null && bodyStartPos !== null) {
                        const paramsEnd = Math.min(lastParamPosEnd, bodyStartPos);
                        if (firstParamPosStart < paramsEnd) {
                            paramsString = originalCode.substring(firstParamPosStart, paramsEnd).trim().replace(/,\s*$/, '');
                        }
                    }

                    // Extract individual param info
                    for (const param of node.params) {
                        paramsInfo.push(extractParamInfo(param, originalCode));
                    }
                }

                // --- Extract Return Type ---
                const returnTypeString = getTypeAnnotationString((node as any).returnType, originalCode);

                let bodyContent = '';
                const firstNodePos = getNodePosition(directiveNode);
                const bodyPos = getNodePosition(bodyNode);
                if (firstNodePos.end !== null && bodyPos.end !== null) {
                    const bodyStart = firstNodePos.end;
                    const bodyEnd = bodyPos.end - 1;
                    if (bodyStart <= bodyEnd) {
                        // Extract body content and strip type annotations
                        bodyContent = stripTypeAnnotations(originalCode.substring(bodyStart, bodyEnd).trim());
                    }
                }

                // --- Store Data ---
                const functionData: UseMainFunctionManifestEntry = {
                    id: uniqueId,
                    name: functionName,
                    params: paramsInfo,
                    paramsString,
                    returnTypeString,
                    body: bodyContent,
                    filePath: normalizedId
                };
                collectedFunctions.set(uniqueId, functionData);
                functionsInFile.set(uniqueId, functionData);
                changed = true; // Mark that *something* in this file was changed

                // --- Replace Body ---
                const bodyPosReplace = getNodePosition(bodyNode);
                if (bodyPosReplace.start !== null && bodyPosReplace.end !== null) { /* ... overwrite logic ... */
                     const replaceStart = bodyPosReplace.start + 1;
                     const replaceEnd = bodyPosReplace.end - 1;
                     if (replaceStart <= replaceEnd) {
                          const replacementBody = ` /* Body Replaced by ${PLUGIN_NAME} */ throw new Error('"${functionName}" is "use main"...'); /* End Replace */ `;
                          magicString.overwrite(replaceStart, replaceEnd, replacementBody);
                     }
                 }
            } // --- End processFunctionNode ---

            // --- Update Manifest & Return ---
            if (changed) {
                try {
                    // Ensure temp directory exists
                    fs.ensureDirSync(tempDirPath);
                    const currentManifest: UseMainManifest = fs.readJsonSync(manifestPath, { throws: false }) || {};
                    functionsInFile.forEach((funcData) => { currentManifest[funcData.id] = funcData; });
                    fs.writeJsonSync(manifestPath, currentManifest, { spaces: 2 });
                } catch (err: any) {
                    logger?.error(`[${PLUGIN_NAME}] Error updating manifest: ${err.message}`, { timestamp: true });
                }
                return {
                    code: magicString.toString(),
                    map: magicString.generateMap({ source: id, includeContent: true, hires: true })
                };
            }
            return null;
        },

        // --- generateBundle (Keep As Is - simplified for brevity) ---
        async generateBundle(options: Rollup.OutputOptions, bundle: Rollup.OutputBundle) {
            // Read manifest
            let manifest: UseMainManifest = {};
            try {
                manifest = await fs.readJSON(manifestPath);
                logger?.info(`[${PLUGIN_NAME}:${target}] Read manifest with ${Object.keys(manifest).length} entries.`);
            } catch (e: any) {
                // If file doesn't exist, treat as empty manifest
                if (e.code === 'ENOENT') {
                    logger?.warn(`[${PLUGIN_NAME}:${target}] No manifest found at ${manifestPath}`);
                    return;
                }
                // For other errors, log error and return
                logger?.error(`[${PLUGIN_NAME}:${target}] Failed read manifest ${manifestPath}: ${e.message}`);
                return;
            }

            const functions = Object.values(manifest);
            if (functions.length === 0) {
                logger?.warn(`[${PLUGIN_NAME}:${target}] No "use main" functions found in manifest. Skipping code generation.`);
                return;
            }

            // Handle preload target
            if (target === 'preload') {
                if (preloadBridgeGenerated) {
                    return; // Skip if already generated
                }
                preloadBridgeGenerated = true;
                const preloadCode = generatePreloadBridgeCode(functions);
                this.emitFile({
                    type: 'asset',
                    fileName: GENERATED_PRELOAD_BRIDGE,
                    source: preloadCode
                });
                logger?.info(`[${PLUGIN_NAME}:preload] Emitted ${GENERATED_PRELOAD_BRIDGE}`);
                return;
            }

            // Handle main target
            if (target === 'main') {
                if (mainHandlersGenerated) {
                    return; // Skip if already generated
                }
                mainHandlersGenerated = true;
                const mainCode = generateMainHandlerCode(functions);
                this.emitFile({
                    type: 'asset',
                    fileName: GENERATED_MAIN_HANDLERS,
                    source: mainCode
                });
                logger?.info(`[${PLUGIN_NAME}:main] Emitted ${GENERATED_MAIN_HANDLERS}`);
                return;
            }
        },
    };
}